#HashTable #Array #BitManipulation

<kbd><span style="color:cyan;">#Easy</span> </kbd>
[Leetcode Link](https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/description/)

---
You are given two **0-indexed** integer permutations `A` and `B` of length `n`.

A **prefix common array** of `A` and `B` is an array `C` such that `C[i]` is equal to the count of numbers that are present at or before the index `i` in both `A` and `B`.

Return _the **prefix common array** of_ `A` _and_ `B`.

A sequence of `n` integers is called a **permutation** if it contains all integers from `1` to `n` exactly once.

---
Учитывая массив целых чисел `nums` и целочисленное значение `target`, верните _индексы двух чисел таким образом, чтобы они складывались в `target`_.

Вы можете предположить, что каждый ввод будет иметь **_ровно_ одно решение**, и вы не можете использовать _один и тот же_ элемент дважды.

Вы можете возвращать ответ в любом порядке.

---
**Example 1:**

>**Input:** A = [1,3,2,4], B = [3,1,2,4]
>**Output:** [0,2,3,4]
>**Explanation:** At i = 0: no number is common, so C[0] = 0.
>At i = 1: 1 and 3 are common in A and B, so C[1] = 2.
>At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.
>At i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.

**Example 2:**

>**Input:** A = [2,3,1], B = [3,1,2]
>**Output:** [0,1,3]
>**Explanation:** At i = 0: no number is common, so C[0] = 0.
>At i = 1: only 3 is common in A and B, so C[1] = 1.
>At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.

**Constraints:**

- `1 <= A.length == B.length == n <= 50`
- `1 <= A[i], B[i] <= n`
- `It is guaranteed that A and B are both a permutation of n integers.`


<kbd><span style="color:red;"> Intuitive</span></kbd>

`Time complexity: O(n)`
`Memory: O(n)`

```Python
class Finishit:
    def vovaMethod(self, s: str, t: str) -> bool:
		
```


<kbd><span style="color:red;"> Intuitive</span></kbd>

`Time complexity: O(n^2)`
`Memory: O(n)`

  
Алгоритм решения этой задачи в Java можно описать следующим образом:

1. Создать массив `C`, который будет содержать результат. Его размер должен совпадать с размером массивов `A` и `B`.
2. Создать два множества (например, `HashSet` в Java), которые будут отслеживать увиденные элементы в массивах `A` и `B`.
3. Пройти по массивам `A` и `B` одновременно, используя цикл от 0 до n-1, где n — размер массивов.
4. На каждом шаге i добавить `A[i]` в множество увиденных элементов из `A` и `B[i]` в множество увиденных элементов из `B`.
5. Вычислить пересечение множеств на текущем шаге (это можно сделать, создав временное множество из одного из них и используя метод `retainAll()` для нахождения общих элементов).
6. Размер пересечения множеств будет значением `C[i]`.
7. Повторять до тех пор, пока не будут обработаны все элементы.

```java
class Solution {
    public int[] findThePrefixCommonArray(int[] A, int[] B) {
         int[] C = new int[A.length];
        Set<Integer> seenA = new HashSet<>();
        Set<Integer> seenB = new HashSet<>();
        
        for (int i = 0; i < A.length; i++) {
            seenA.add(A[i]);
            seenB.add(B[i]);
            
            // Создаем копию одного множества для нахождения пересечения
            Set<Integer> common = new HashSet<>(seenA);
            common.retainAll(seenB);
            C[i] = common.size();
        }
        
        return C;
    }
}
```

### Временная сложность

1. **Цикл по массивам `A` и `B`**: O(n), где n - длина массивов `A` и `B`. Поскольку оба массива имеют одинаковую длину, цикл выполняется n раз.
    
2. **Добавление элементов в `seenA` и `seenB`**: В каждой итерации цикла элементы добавляются в множества `seenA` и `seenB`. Добавление элемента в `HashSet` выполняется за амортизированное время O(1).
    
3. **Создание копии множества и нахождение пересечения**: На каждом шаге создается копия множества `seenA` и выполняется операция `retainAll(seenB)`, чтобы найти пересечение множеств. Создание копии множества выполняется за O(k), где k - количество элементов в `seenA` на момент создания копии. Операция `retainAll` также может занять до O(k) времени в худшем случае, если размеры множеств сравнимы. Поскольку `k` растет от 1 до n в ходе выполнения алгоритма, общее время, затраченное на эти операции, будет O(n^2) в худшем случае.
    

Итак, общая временная сложность алгоритма составляет O(n^2) из-за операций с множествами на каждом шаге цикла.

### Пространственная сложность

1. **Множества `seenA` и `seenB`**: Каждое из этих множеств в худшем случае может содержать все уникальные элементы из соответствующих массивов, что требует O(n) дополнительной памяти.
    
2. **Множество `common`**: На каждом шаге создается новое множество для хранения пересечения. В худшем случае, оно также может содержать до n элементов, но поскольку это множество не сохраняется между итерациями, его память может быть рассмотрена как переиспользуемая, и максимальный объем занимаемой памяти одновременно для всех множеств останется O(n).
    

Итак, общая пространственная сложность алгоритма составляет O(n), учитывая необходимость хранения всех уникальных элементов из массивов `A` и `B` в худшем случае.

---
## Solution №2 More effectivly

`Time complexity: O(n)`
`Memory: O(n)`

Это решение использует один массив (`seen`) для отслеживания количества раз, которое встречается каждое число в массивах `A` и `B`, и одну переменную (`cur`) для подсчета количества общих чисел на текущий момент.

Давайте подробнее разберем этот алгоритм:

1. Объявляется массив `ans` той же длины, что и входные массивы `A` и `B`. Этот массив будет хранить результирующий префиксный общий массив.
    
2. Объявляется массив `seen` размером `n + 1`, где `n` — длина массивов `A` и `B`. Этот массив используется для отслеживания, сколько раз встретилось каждое число из диапазона `[1, n]`. Поскольку числа в массивах являются перестановками чисел от 1 до `n`, индексация в массиве `seen` начинается с 1, и дополнительный элемент используется для учета числа `n`.
    
3. Переменная `cur` инициализируется нулем и будет использоваться для подсчета количества общих чисел на каждом шаге.
    
4. Цикл от 0 до `n - 1` используется для одновременного прохода по массивам `A` и `B`.
    
5. Для каждого элемента `A[i]` и `B[i]`, инкрементируется значение в массиве `seen` на соответствующей позиции. Если после увеличения значение становится равным 2, это означает, что текущее число теперь встретилось в обоих массивах, и переменная `cur` увеличивается на 1.
    
6. После обработки `A[i]` и `B[i]`, текущее значение `cur` сохраняется в `ans[i]`, что соответствует количеству общих чисел до индекса `i` включительно.
    
7. После завершения цикла, массив `ans` возвращается как результат работы функции.
    

Этот метод эффективен, поскольку он использует только один дополнительный массив для отслеживания увиденных чисел и делает это в один проход, что дает линейную временную сложность O(n).

```java
public class Solution {
    public int[] findThePrefixCommonArray(int[] A, int[] B) {
        int cur = 0, n = A.length;
        int[] ans = new int[n];
        int[] seen = new int[n + 1];

        for (int i = 0; i < n; ++i) {
            if (++seen[A[i]] == 2)
                cur++;
            if (++seen[B[i]] == 2)
                cur++;
            ans[i] = cur;
        }

        return ans;
    }
}
```