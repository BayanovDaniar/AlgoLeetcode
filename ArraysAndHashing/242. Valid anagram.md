#HashTable #Sorting #String

<kbd><span style="color:cyan;">#Easy</span> </kbd>

---
Given two strings `s` and `t`, return `true` _if_ `t` _is an anagram of_ `s`_, and_ `false` _otherwise_.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

---
Учитывая две строки `s` и `t`, верните `true`, если `t` является анаграммой `s`, и `false` в противном случае.

Анаграмма - это слово или фраза, образованные путем перестановки букв другого слова или 
фразы, обычно используя все исходные буквы ровно один раз.

---
**Example 1:**

>**Input:** s = "anagram", t = "nagaram"
>**Output:** true

**Example 2:**

>**Input:** s = "rat", t = "car"
>**Output:** false

**Constraints**
- ` 1 <= nums.length <= 10^5
-  ` -10^9 <= nums[i] <= 10^9

<kbd><span style="color:red;"> Intuitive</span></kbd>
Создаем два словаря. Пробегаемся для каждого слова циклом и добавляем в словарь букву. 
В конце проверяем равенство между словарями.

```Python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        countS, countT = {}, {}

        for i in range(len(s)):
            countS[s[i]] = 1 + countS.get(s[i], 0)
            countT[t[i]] = 1 + countT.get(t[i], 0)
        return countS == countT

```

<kbd><span style="color:red;"> Intuitive</span></kbd>

Создаем массив на 26 символов. Циклом пробегаем по словам обращаясь по индексу как по коду символа. Для первого слова увеличиваем, для второго уменьшаем. 

В итоге должно быть ноль во всех элементах массива.

```run-java

class Solution {

    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) return false;

        int[] store = new int[26];

        for (int i = 0; i < s.length(); i++) {
            store[s.charAt(i) - 'a']++;
            store[t.charAt(i) - 'a']--;
        }

        for (int n : store) if (n != 0) return false;

        return true;
    }
}

```

