#TwoPointers #Array #Stack #DynamicProgramming #MonotonicStack

<kbd><span style="color:red;">#Hard</span> </kbd>
[Leetcode Link](https://leetcode.com/problems/trapping-rain-water/description/)

---
Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.

---
Учитывая `n` неотрицательных целых чисел, представляющих карту высот, где ширина каждой полосы равна `1`, вычислите, сколько воды она может задержать после дождя.

---
**Example 1:**

![[Pasted image 20240125134126.png]]

>**Input:** height = [0,1,0,2,1,0,1,3,2,1,2,1]
>**Output:** 6
>**Explanation:** The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.

**Example 2:**

>**Input:** height = [4,2,0,3,2,5]
>**Output:** 9


**Constraints:**

- `n == height.length`
- `2 <= n <= 10^5`
- `0 <= height[i] <= 10^4`


<kbd><span style="color:red;"> Intuitive</span></kbd>


```Python
class Finishit:
    def vovaMethod(self, s: str, t: str) -> bool:
		print("Vova finish it !")
```


<kbd><span style="color:red;"> Intuitive</span></kbd>

`Time complexity: O(NLogN)`
`Memory: O(1)`

1. Делаем стандартный левый и правый указатель.
2. Пока левый меньше правого итерируемся.
3. Считаем длину контейнера. И затем считаем площадь = длину * минимальный из значений левого и правого указателя.
4. Результат фиксируем, если больше предыдущего максимального результата.
5. Если левая меньше двигаем левую границу.

```java
class Solution {
    public int trap(int[] height) {
        if(height.length < 2) return 0;
        int left = 0, right = height.length - 1;
        int maxLeft = height[left], maxRight = height[right], result = 0;
        while(left < right){
            if(maxLeft < maxRight){
                left++;
                maxLeft = Math.max(maxLeft, height[left]);
                result += maxLeft - height[left];
            }else {
                right--;
                maxRight = Math.max(maxRight, height[right]);
                result += maxRight - height[right];
            }
        }
        return result;
    }
}

```

