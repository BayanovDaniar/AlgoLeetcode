#TwoPointers #String 

<kbd><span style="color:orange;">#Medium</span> </kbd>
[Leetcode Link](https://leetcode.com/problems/one-edit-distance)

---
Given two strings **_s_** and **_t_**, determine if they are both one edit distance apart.

**Note:** 

There are 3 possiblities to satisify one edit distance apart:

1. Insert a character into **_s_** to get **_t_**
2. Delete a character from **_s_** to get **_t_**
3. Replace a character of **_s_** to get **_t_**

---
Учитывая две строки **_s_** и **_t_**, определите, находятся ли они на расстоянии одной правки друг от друга.

**Примечание:** 

Существует 3 возможности для определения расстояния одной правки друг от друга:

1. Вставьте символ в **_s_**, чтобы получить **_t_**
2. Удалите символ из **_s_**, чтобы получить **_t_**
3. Замените символ **_s_**, чтобы получить **_t_**

---
**Example 1:**

>**Input:** **_s_** = "ab", **_t_** = "acb"
>**Output:** true
>**Explanation:** We can insert 'c' into **_s_** to get **_t._**

**Example 2:**

>**Input:** **_s_** = "cab", **_t_** = "ad"
>**Output:** false
>**Explanation:** We cannot get **_t_** from **_s_** by only one step.

**Example 3:**

>**Input:** **_s_** = "1203", **_t_** = "1213"
>**Output:** true
>**Explanation:** We can replace '0' with '1' to get **_t._**


***Constraints:**

- `0 <= s.length, t.length <= 104`
- `s` and `t` consist of lowercase letters, uppercase letters, and digits.


<kbd><span style="color:red;"> Intuitive</span></kbd>


```Python
class Finishit:
    def vovaMethod(self, s: str, t: str) -> bool:
		print("Vova finish it !")
```


<kbd><span style="color:red;"> Intuitive</span></kbd>

`Time complexity: O(M) , M -  length min string` 
`Memory: O(1)`

1. **Итерация по символам строк**: Цикл перебирает символы обеих строк до конца самой короткой строки. Это делается для проверки, есть ли различие в символах на одинаковых позициях.

2. **Обнаружение различия в символах**:
- Если символы на текущей позиции в строках **_s_** и **_t_** различаются, алгоритм проверяет три возможных случая редактирования:
 - **Замена символа**: Если длины строк **_s_** и **_t_** одинаковы, алгоритм проверяет, равны ли подстроки после текущего символа. Возвращает `true`, если остальные символы идентичны.
 - **Вставка символа**: Если строка **_s_** короче строки **_t_**, алгоритм проверяет, равна ли подстрока **_s_** начиная с текущего символа подстроке **_t_**, начиная со следующего символа. Возвращает `true`, если остальные символы идентичны.
 - **Удаление символа**: Если строка **_s_** длиннее строки **_t_**, алгоритм проверяет, равна ли подстрока **_s_**, начиная со следующего символа, подстроке **_t_** начиная с текущего символа. Возвращает `true`, если остальные символы идентичны.

3. **Обработка случая, когда одна строка длиннее другой**:
   - После цикла проверяется, равна ли разница в длине строк единице (`Math.abs(s.length() - t.length()) == 1`). Это означает, что в одной строке либо отсутствует один символ, либо присутствует лишний символ по сравнению с другой строкой. Возвращает `true`, если это так.

4. **Возвращение результата**: Функция возвращает `true`, если найдено одно редактирование, которое превращает одну строку в другую, и `false` в противном случае.

Этот метод эффективно проверяет возможность преобразования одной строки в другую с помощью одной операции редактирования (вставки, удаления или замены символа).

```java
class Solution {
	public boolean isOneEditDistance(String s, String t) {
        for (int i = 0; i < Math.min(s.length(), t.length()); ++i) {
            if (s.charAt(i) != t.charAt(i)) {
                if (s.length() == t.length()) {
                    return Objects.equals(s.substring(i + 1), t.substring(i + 1));
                }
                if (s.length() < t.length()) {
                    return Objects.equals(s.substring(i), t.substring(i + 1));
                } else {
                    return Objects.equals(s.substring(i + 1), t.substring(i));
                }
            }
        }

        // case: abc, abcdefg
        return Math.abs((int)s.length() - (int)t.length()) == 1;
    }
}
```


Оценка сложности :
### Временная сложность

1. **Цикл по символам строк**: Временная сложность этого цикла зависит от длины самой короткой строки между _s_ и _t_. Пусть _m_ – длина самой короткой строки. Тогда, в худшем случае, цикл будет выполняться _m_ раз.

2. **Проверка условий замены, вставки или удаления**: Каждая проверка включает в себя сравнение двух подстрок. В худшем случае (когда различие находится в конце строк) потребуется сравнить до _m_ символов. Однако, поскольку это происходит только один раз и внутри цикла, это не увеличивает асимптотическую сложность.

3. **Проверка длины строк**: Это выполняется за постоянное время после цикла.

Итак, общая временная сложность алгоритма составляет **O(m)**, где _m_ – длина самой короткой из двух строк.

### Пространственная сложность

1. **Переменные**: Используются только несколько переменных для хранения индексов, длин строк и сравнения подстрок, что требует постоянного объема памяти.

2. **Подстроки**: В худшем случае, при сравнении подстрок, может потребоваться дополнительное пространство. Однако, в Java, метод `substring` не создает новую строку, а возвращает новый объект `String`, который указывает на тот же массив символов, что и исходная строка. Таким образом, это не увеличивает пространственную сложность.

Исходя из этого, пространственная сложность алгоритма составляет **O(1)**, то есть она является постоянной.

Таким образом, представленный алгоритм является эффективным как с точки зрения времени исполнения, так и с точки зрения затрат памяти.